Ek Ders Soru-Çözümler ( 21.02.2021 )
```
(1)//11

#include <iostream>

int main () 
{
    static int a;
    std :: cout << a;
}

***************************** 
AÇIKLAMA : C++ da static değişkenler yani global değişkenler default initialize edilirlerse 
           ilk olarak zero initialize edilirler. Bu da aritmetik türden nesnelerin sıfır 
           değeri ile başlaması, boolean değişkenlerin false, pointer değişkenlerin nullptr, 
           sınıf türünden nesnelerin default ctor larının çağırılması demektir. Referanslar 
           ve const nesneler default initialize edildiğinde syntax error olur.   
*****************************

*****************************
CEVAP : 0
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(2)//2
#include <iostream> 

class A {
    int foo = 0;       //non-static data member. (def. member init)
public :
    int& getFoo () {
        return foo;
    }

    void printFoo ()const {
        std :: cout << foo;
    }
};

int main ()  
{ 
    A a;                      
    auto bar = a.getFoo ();
    ++bar;

    a.printFoo ();
} 

***************************** 
AÇIKLAMA :  a nesnesi def. init edildi. non-static data member ile hayata geldi. 
            (sıfır değeri ile)
            getFoo sınıfın veri elemanını referans semantiği ile döndürür. Ancak 
            auto specifier'ını kullanırken bar nesnesinde &(referans) declarator'u 
            yok. Dolayısıyla getFoo 'nun geri dönüş değeri referans olmasına rağmen
            bar değişkeni referans değil doğrudan int türdendir. Bar değişkeni sınıfın 
            veri elemanına referans değildir. Bu yüzden bar++ işlemi yapıldığında 
            sınıfın veri elemanı artmaz sıfır değerinde kalır. auto &bar = a.getFoo() 
            olsaydı cevap 1 olurdu.            
***************************** 
***************************** 
CEVAP :  0
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(3)//16 
#include <iostream> 

class A {
public :
    A () {
        std :: cout << 'a';
    }

  
    ~A () { 
        std :: cout << 'A'; 
    }
};
  
class B { 
public : 
    B () { 
        std :: cout << 'b'; 
    } 
   
    ~B () {  
        std :: cout << 'B';  
    } 

    A a;
};

int main ()  
{ 
    B b;
} 
***************************** 
AÇIKLAMA : B sınıfı composition ilişkisi ile A sınıfı türünden bir veri elemanı almıştır. 
           Bir B sınıfı nesnesi hayata geldiğinde önce ctor initalizer list ile B sınıfının
           ana bloğuna girmeden eleman alan A sınıfı nesnesi hayata gelecektir. 
***************************** 
***************************** 
CEVAP :  abBA
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(4)//3
#include <iostream>

void f(int) {
    std :: cout << 1;
}

void f (unsigned) {
    std :: cout << 2;
}

int main ()  
{ 
    f (2.6);
} 
***************************** 
AÇIKLAMA :  ambiguity 
***************************** 
***************************** 
CEVAP :  syntax error
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(5)//120
#include <iostream> 

int main ()  
{ 
    int a = 10;
    int b = 20;
    int x;
    x = a, b;
    std :: cout << x;
} 

***************************** 
AÇIKLAMA : a ve b arasındaki virgül operatordur. Soru operator önceliği ile ilgilidir. 
           atama operatoru virgülden daha yüksek önceliklidir. b virgül operatorunun 
           sağ operandıdır. Yani x 'e a'nın değeri atanır. 
           x = (a, b); olsaydı cevap  20 olurdu.
***************************** 
***************************** 
CEVAP :  10
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(6)//277
#include <iostream> 

int main ()  
{ 
    std :: cout << sizeof ("");
} 
***************************** 
AÇIKLAMA : Bu bir string literalidir. String literalleri const char dizilerdir.
           Bu dizi const char [1] dir. Çünkü NULL karakter vardır. C olsaydı char 
           dizi olurdu. 
***************************** 
***************************** 
CEVAP :  1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(7)//8
#include <iostream> 

class A {
public :
    virtual void f() {
        std :: cout << "A";
    }
};

class B : public A { 
public : 
    void f()override { 
        std :: cout << "B"; 
    } 
};

void g (A a) {
    a.f();
}

int main ()  
{ 
    B b;
    g (b);
} 

***************************** 
AÇIKLAMA :  g fonksiyonunun parametresi referans değildir. Dolayısıyla sanallık 
            mekanizması (virtual dispatch) devreye girmez. Çağırılan A sınıfının 
            fonksiyonudur. void g (A &a) olsaydı sanallık devreye girer ve cevap B olurdu. 
***************************** 
***************************** 
CEVAP :  A
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(8)//265
#include <iostream> 

void f (char*&&) {
    std :: cout << 1;
}

void f (char*&) { 
    std :: cout << 2; 
}

int main ()  
{ 
    char c = 'a';
    f (&c);
} 
***************************** 
AÇIKLAMA : Üstteki fonksiyonun parametresi sağ taraf referansı alttakinin sol taraf 
           referansıdır. Derleyici function overresolution'da gönderilen ifadenin 
           value kategorisine bakacaktır. Adres operatoruyle oluşturulan ifadenin
           değer kategorisi PR value expression'dır. Dolayısıyla sağ taraf referans 
           parametreli olan çağırılır. Üstteki fonksiyon hiç olmasaydı maindeki çağrı
           viable olmazdı. Sytax error olurdu.   
***************************** 
***************************** 
CEVAP :  1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(9)//208 
#include <iostream> 
#include <map>

using namespace std;

bool default_constructed = false;
bool constructed = false;
bool assigned = false;

class C {
public :
    C () {
        default_constructed = true;
    }
    
    C (int) {
        constructed = true;
    }

    C& operator=(const C&) {
        assigned = true;
        return *this;
    }
};        

int main ()  
{ 
    map <int, C> m;
    m[7] = C(1);
    
    cout << default_constructed << contructed << assigned;

} 
***************************** 
AÇIKLAMA : map konteynırında key type olarak int,  value type olarak C sınıfı 
           kullanılmıştır. Köşeli parantez içindeki değer eğer map içinde varsa 
           onun değerini set eder. C(1) ile bir geçici nesne oluşturulur.  
           contructed true olur. Köşeli parantez operatoru çağırılacağı için C 
           default constuct edilecektir. Bir de bunun value'suna yapılan atama vardır. 
***************************** 
***************************** 
CEVAP :  111
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(10)//5
#include <iostream> 

struct A {
    A () {
        std :: cout << "A";
    }
};

struct B { 
    B () { 
        std :: cout << "B"; 
    } 
};

class C { 
public :
     C () : a(), b() { }
private :
    B b;
    A a;
};

int main ()  
{ 
     C c;
} 
***************************** 
AÇIKLAMA :  C sınıfında yapılan contructor initializer list sırası belirleyici 
            değildir. Sınıfın tanımında yani private alandaki bildirim sırası önemlidir.  
***************************** 
***************************** 
CEVAP :  BA
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(11)//33
#include <iostream> 

struct GeneralException {
    virtual void print ()const {
        std :: cout << "G";
    }
};

struct SpecialException : public GeneralException {
    void print ()const override {
        std :: cout << "S";
    }
};

void f () {
    throw SpecialException();
}

int main ()  
{ 
    try {
        f ();
    }
    catch (const GeneralException e) {
        e.print();
    }
} 
***************************** 
AÇIKLAMA :  Ancak bu soru da referans semantiği ile değil kopyalama semantiği ile 
            hata yakalanmış. Yapılması tavsiye edilmez. Yani print() sanal bir 
            fonksiyondur. Ancak virtual dispatch mekanizması devreye girmez. Çağırılan
            GeneralException sınıfının print fonksiyonu olacak.  catch 
            (GeneralException &e) olsaydı sanallık devreye girer ve CEVAP : S olurdu.
***************************** 
***************************** 
CEVAP :  G
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(12)//38
#include <iostream> 

int main ()  
{ 
    int a  = 0;
    decltype ((a)) b = a;
    b++;
    std :: cout << a << b;
} 
***************************** 
AÇIKLAMA :  decltyep (a) olsaydı tür çıkarımı kuralı farklı olurdu. Eğer decltype'ın 
            operandı olan bir isim ise; elde edilen tür referans türü değildir. 
            Bu durumda CEVAP : 01 olurdu. Parantez içine alınınca ((a)) ifadenin 
            value kategorsine göre değişir. Bu örnekte L value expression'dur.
            Elde edilen tür referans türüdür. Elde edilen tür PR value ise türün kendisi,
            X value expression ise sağ taraf referansıdır. 
            Sonuç olarak b a nesnesine referans oldu.  
***************************** 
***************************** 
CEVAP :  11
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(13)//38-1
#include <iostream> 

int main ()  
{ 
    int x = 10;
    int* p { &x };
    decltype (*p) a = x;
    ++a;

    std :: cout << "x = " << x << "\n";
} 
***************************** 
AÇIKLAMA : Decltype'ın operandı olan p bir isim mi? HAYIR. Bir expression. Bu ifadenin 
           value kategorisine bakılacak. İçerik operatoru ile oluşturulmuş ifadelerin 
           kategorisi L value expression. Bu durumda a x'e referans olur.
           
***************************** 
***************************** 
CEVAP :  x = 11
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(14)//7
#include <iostream> 

class A {
public :
    void f() {
        std :: cout << "A";
    }
};

class B : public A {
public :
    void f() {
        std :: cout << "B";
    }
};

void g (A& a) {        //A taban sınıfı türünden olduğu için parametre legaldir.
    a.f ();
}

int main ()  
{  
    B b;
    g (b);
} 
***************************** 
AÇIKLAMA : Soru name-lookup ile ilgilidir.
           a.f() için isim arama taban sınıftan başlayacaktır. Aranan isim bulundu. 
           Sanal fonksiyon yok.   
***************************** 
***************************** 
CEVAP :  A
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

//7 -1
#include <iostream>  

class A { 
public : 
    virtual void f() { 
        std :: cout << "A"; 
    } 
}; 
class B : public A { 
public : 
    void f()override { 
        std :: cout << "B"; 
    } 
}; 
void g (A& a) {        //A taban sınıfı türünden olduğu için parametre legaldir. 
    a.f (); 
} 
int main ()   
{   
    B b; 
    g (b); 
}
***************************** 
AÇIKLAMA :       
***************************** 
***************************** 
CEVAP :  B
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(15)//9
#include <iostream> 

int f (int& a, int& b) {
    a = 3;
    b = 4;
    return a + b;
}

int main ()  
{ 
    int a = 1;
    int b = 2;
    int c = f (a, a);
    std :: cout << a << b << c;
} 
***************************** 
AÇIKLAMA : referans semantiğini sorgulayan bir sorudur.
           int f (....) fonksiyonundaki a ve b de main deki a nesnesine referanstır. 
           f (a, a) çağırıldığı için. a = 3 ifadesiyle main de 1 olan a 3 oldu. b = 4 
           ifadesindeki b nesnesi de a ya referans olduğu için a 4 oldu. a + b deki 
           işlem 4 + 4 olarak c ye 8 atanmış oldu. 
***************************** 
***************************** 
CEVAP :  428
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(16)//18
#include <iostream>  

class A {
public :
    virtual void f() {
        std :: cou << "A";
    }
};

class B : public A { 
private : 
    void f() { 
        std :: cou << "B"; 
    } 
};

void g (A& a) {
    a.f();
}

int main ()   
{  
    B b;
    g(b);   
}  
*****************************  
AÇIKLAMA : türemiş sınıfın override edilen fonksiyonunun public veya private alanda
           olması run-time a yönelik değildir. compile-time a yöneliktir. A taban 
           sınıfındaki sanal fonksiyon private alanda olsaydı syntax error olurdu.
           
            class Myclass {
            public :
                void foo () {
                    //
                    func(); //client kodlar public kısma erişir oradan sanal fonksiyona erişilir.
                }
            private :
                virtual void func();
            };
            Bu yanlış anlaşılmanın aksine daha yaygın bir kullanımdır. 
            (non-virtual interface idiom)
*****************************  
*****************************  
CEVAP :   
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(17)//13
#include <iostream>  

class A {
public:
    A () {
        std :: cout << "a";
    }

    ~A () { 
        std :: cout << "A"; 
    }
};

class B { 
public: 
    B () { 
        std :: cout << "b"; 
    } 
    ~B () {  
        std :: cout << "B";  
    } 
};

class C { 
public: 
    C () { 
        std :: cout << "c"; 
    } 
    ~C () {  
        std :: cout << "C";  
    } 
};

A a;

int main ()   
{  
    C c;
    B b;
}  
*****************************  
AÇIKLAMA :  static ömürlü nesneler main deki ilk fonksiyon çağrısından önce diye 
            standartlarda geçer. Önce global değişken olan a'nın ctor'ı çağırılır.
            sequence point (deyim sonu demek) ( noktalı virgül gibi) Hayata son 
            gelen yani b ilk veda etti önce onun dtor'u çağırıldı. Sonra b ve a nın sırayla.
*****************************  
*****************************  
CEVAP :   acbBCA
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(18)//279  
#include <iostream>  
#include <variant>

strcut C {
    C () : i (1) {}
    int i;
};

struct D {
    D () : i (2) {}
    int i;
}; 

int main ()   
{  
    const std :: variant <C, D> v;
    std :: visit ([](const auto& val) {std :: cout << val.i; }, v);
}  
*****************************  
AÇIKLAMA : C++ 17 ile gelmiştir.
           Önceden belirlenmiş n tane türün birinden değer tutar ve bir indis ile 
           hangilerini tuttuğunu sarmalar. bu variat ya C tutar ya da D tutar 
           demektir. Bu sınıfın üye fonksiyonları vardır. variant sınıfının index 
           fonksiyonu variant'ın tuttuğu öğenin ( c veya d) tür olarak indexini verir.
           const variant <C, D> v;
           std :: cout << v.index () << "\n"; dersek eğer CEVAP : 0 olur. 
           Default sıfır değerini alır çünkü.


           visit bir globan fonksiyon şablonudur. 
           visit' e bir callable argüman olarak verilir. bu bir function object olabilir
           veya bu sorudaki gibi bir lambda ifadesi olabilir. 
           [](const auto& val) {std :: cout << val.i; }
           bu callable nesnesi bir alternative ile çağırılacaktır. bu da variantta o an 
           tutulan öğedir. C nesnesi olduğu için 1 dir.
*****************************  
*****************************  
CEVAP :   1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(19)//26  
#include <iostream>  

int main ()   
{  
    int i = 42;
    int j = 1;
    std :: cout << i / --j; 
}  
*****************************  
AÇIKLAMA : Sıfıra bölme durumu oluşur. -- operatoru ön ek konumunda olduğu için -- 
           operatorunun ürettiği değer sıfır olur. j-- olsaydı legal olurdu.   
*****************************  
*****************************  
CEVAP :   UB
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(20)//197
#include <iostream>  

int j = 1;

int main ()   
{ 
    int& i = j, j;
    j = 2;
    
    std :: cout << i << j; 
}  
*****************************  
AÇIKLAMA :  int& i = j, j; deki virgül bir operator değildir. Burası bildirimdir. 
            parantez içine alınsaydı: 
            int& i = (j, j); operator olurdu.
            
            int& i = j, j; ifadesi ile
            int& i = j;
            int j; aynı anlamdadır.

            Yani i global olan j ye referanstır. int& i = ::j, j; şeklindedir. 
            diğer j ise yerel j dir.
              
*****************************  
*****************************  
CEVAP :   12
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(21)//
#include <iostream>  

namespace x {
    class C {};
    
    void f (const C& i) {
        std :: cout << "1";
    }
}

namespace y {
    void f (const x :: C& i) { 
        std :: cout << "2"; 
    } 
}

int main ()   
{  
     f (x :: C());
}  
*****************************  
AÇIKLAMA : ADL sınanmıştır.(argument dependent look-up)
           
*****************************  
*****************************  
CEVAP :   1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

//ADL örnek 1
#include <iostream>  
#include <vector>
#include <algorithm>

int main ()   
{  
    std :: vector<int> ivec; 
    sort (ivec.begin(), ivec.end());
    sort ( next( ivec.begin() ), prev( ivec.end() ) );
}  
*****************************  
AÇIKLAMA :  using bildirimi yapmamış olmamıza rağmen hata vermiyor. Bu fonksiyonun 
            geri dönüş değeri iterator nested type'ı std namespace'i içinde 
            tanımlanan türdür. Argüman std namespace'inde olduğu için sort ismi normal 
            arandığı yerin dışında std namespace'inde de aranacaktır. 
            Aynı şekilde:  
            prev ve next stood namespace'İndedir.
*****************************  
*****************************  
CEVAP :   
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

//ADL örnek 2
#include <iostream>  

namespace Bar {
    class X {};
    void f (X) {
        std :: cout << "1";
    }
}

void f (Bar :: X) {
    std :: cout << "2";
}

int main ()   
{ 8
    Bar :: X x;
    f(x);  
}  
*****************************  
AÇIKLAMA :  f(x) çağrısı ambiguity durumudur ve syntax error olur.
            Bar namespace'indeki f fonksiyonu ADL ile görünür durumda, 
            diğeri de doğrudan görünür durumdadır.  
*****************************  
*****************************  
CEVAP :   Ambiguity
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(22)//
#include <iostream>  

int i;

void f (int x) {
    std :: cout << x << i;
}

int main ()   
{  
    i = 3;
    f (i++); 
}  
*****************************  
AÇIKLAMA :  i = 3 deki i global i'dir. f(i++) daki işlem sonucu 3 dür. 
            x e kopyalanan değer 3.
            i için son ek ++ işlevi gerçekleşir ve değerini 1 artırır.
*****************************  
*****************************  
CEVAP :   34
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(23)//
#include <iostream>  

strcut S {
    int one;
    int two;
    int three;
};

int main ()   
{  
    S s{ 1, 2 }; 
    std :: cout << s.one;
}  
*****************************  
AÇIKLAMA : C++ da bir tür kategorisi vardır. aggregate initialization durumu vardır.
           aggregate initialization olması için belli koşullar olmalıır. user defined 
           ctor olmayacak, private bölümü olmayacak, sanal fonksiyonu olmayacak gibi..
            
           
*****************************  
*****************************  
CEVAP :   1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(24)//11  
#include <iostream>  
#include <type_traits>

int main ()   
{  
     std :: cout << std :: is_signed <char> :: value;
}  
*****************************  
AÇIKLAMA :    char, signed char ve unsigned char distinct (farklı) türlerdir. 
              char türünün işaretli mi işaretsiz mi olduğu implementation defined dır.
               value boolean değer ya true ya da false olacaktır. Bu da derleyiciye bağlıdır.
               Ayrıca is_signed meta function olarak geçer. 
*****************************  
*****************************  
CEVAP :   implementation defined
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(25)//226 
#include <iostream>  
#include <utility>

struct X {
    X () {
        std :: cout << "1";
    }

    X (X&) {                       //copy ctor
        std :: cout << "2"; 
    }

    X (const X&) {                 //copy ctor
        std :: cout << "3"; 
    }

    X (X&&) { 
        std :: cout << "4"; 
    }

    ~X () { 
        std :: cout << "5"; 
    }
 }

struct Y {
    mutable X x;
    Y () = default;
    Y (const Y&) = default;        //derleyici tarafından yazılmıştır.
};

int main ()   
{  
    Y y1;
    Y y2 = std :: move (y1); 
}  
*****************************  
AÇIKLAMA :   Sadece Y y1; olsaydı; Y nin içinde bir X nesnesi olduğu için X'in 
             default ctor'ı çağırılacaktı. Sonra Y  Y'nin dtor'ı çağırıldığında 
             o da X'in dtor'ını çağırırdı ve CEVAP : 15 olurdu.
            
             Normal durumda move tür dönüştürme fonksiyonu ile normalde L value 
             olan y1 move'un geri dönüş değeri R  value expression. yani y2 
             nesnesine R value ile ilk değer verilir. Ancak Y sınıfında move ctor 
             yazılmamış. move ctor olmadığı için copy ctor (Y (const Y&) = defalut;) 
             çağırılır. 
             X mutable olmasaydı dilin kurallarına göre CEVAP : 1355 olurdu.
*****************************  
*****************************  
CEVAP : 1255  
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(26)//112
#include <iostream>  
#include <utility>

struct A {
    A () {                         //default ctor
        std :: cout << "1;
    }

    A (const A&) {                 //copy ctor 
        std :: cout << "2";  
    } 
    A (A&&) {                     //move ctor
        std :: cout << "3";  
    }
};

struct B { 
    A a;
    
    B () { 
        std :: cout << "4; 
    } 
    B (const B& b) : a (b.a) {                         
        std :: cout << "5";   
    } 
    B (B&& b) : a (b.a) {   
        std :: cout << "6";   
    } 
};

int main ()   
{  
    B b1;
    B b2 = std :: move (b1); 
}  
*****************************  
AÇIKLAMA : B b2 = std :: move (b1); olmasaydı CEVAP : 14 olurdu. move fonksiyonu ile 
           L value expr olan b1 PR value expr. dönüştürülür ve b2 nesnesine atanır. 
           B b2 = b1; olsaydı copy ctor çağırılacaktı, ancak şimdi move ctor çağırılır.
           a (b.a) işlemi de ctor initialize list işlemidir ve yeniden copy ctor'ı 
           çağırılır. b.a ifadesi de L value expr'dir. a ya gönderilen L value expr 
           olduğu için move değil copy ctor çağırılır.
           B (const B& b) : a (std :: move(b.a)) { şeklinde olsaydı CEVAP : 1436 olurdu. 
           Çünkü move ctor çağırılırdı.
           
*****************************  
*****************************  
CEVAP : 1426
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(27)//105
#include <iostream>   

using namespace std;

class A {
public :
    A () {
        cout << "a";
    }
    
    ~A () {
        cout << "A";
    }
};

int i = 1;

int main ()    
{   
    label :
        A a;
        if (i--) {
            goto label;
        } 
}   
*****************************   
AÇIKLAMA :  goto ile label ifadesine tekrar gittiğinde scope bitmiş gibi varsayılır 
            ve dtor çağırılır. 
*****************************   
*****************************   
CEVAP :  aAaA
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(28)//186 
#include <iostream>   
 #include <typeinfo>

void takes_pointer (int* pointer) {
    if (typeid(pointer) == typeid (int[])) std :: cout << "a";
    if (typeid(pointer) == typeid (int*)) std :: cout << "p";
}

void takes_array (int array[]) { 
    if (typeid(array) == typeid (int[])) std :: cout << "a"; 
    if (typeid(array) == typeid (int*)) std :: cout << "p"; 
} 

int main ()    
{   
    int* pointer = nullptr;
    int array[1];

    takes_pointer(array);          //array decay (array to pointer dönüşümü)
    takes_array(pointer);
}   
*****************************   
AÇIKLAMA :  takes_pointer(array); fonksiyonunun parametresine array dizisinin adresi 
            gönderilir. typeid compile-time a ilişkindir. Bizi type_info nesnesine 
            erişimi sağlar. pointer'ın türü int*, int[] ise incomplate dizi türüdür. 
            Yani ilk if ifadesindeki eşitlik sağlanmaz. Ekrana p yazılır.
            Diğer fonksiyon içinde aynı kontrol yapılacak ve Ekrana pp yazılacaktır.
            
*****************************   
*****************************   
CEVAP : pp0 
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(29)//195
#include <iostream>   
#include <cstddef>
#include <type_traits>

int main ()    
{   
    std :: cout << std :: is_pointer_v <decltype(nullptr)>;
    //std :: cout << std :: is_pointer <decltype(nullptr)>::value;        
    //üstteki ile aynı anlamdadır. Bu value taban sınıftan gelen veri elemanıdr.
}   
*****************************   
AÇIKLAMA :  is_pointer_v bir variable template.
            nullptr_t türüdür. bu pointer'a dönüşebilen bir class type.
*****************************   
*****************************   
CEVAP :  0
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(30)//129
#include <iostream>  

struct A {
    A () {
        foo();
    }

    virtual ~A () {
        foo();
    }

    virtaul void foo () {
        std :: cout << "1";
    }

    void bar () {
        foo();
    }
};

struct B : public A {
    virtual void foo()override {
        std :: cout << "2";
    }
};

int main ()    
{   
    B b;
    b.bar();  
} 

*****************************   
AÇIKLAMA :  B sınıfı türünden b nesnesi oluşunca b için ctor çağırıldı. Onun için 
            de taban sınıf olan A sınıfının ctor'ı çağırıldı.
            Ctor için yapılan sanal fonksiyon çağrılarında sanallık mekanizması 
            devreye girmez!!!!!!!!!!!!
            Yani ctor içinde çağırılan foo fonksiyonu taban sınıfın foo fonksiyonudur. 
            Yani 1 yazılacak.
            b.bar() çağrısında sanallık devreye girer. B sınıfının override edilen foo 
            fonksiyonu çağırılır. Ekrana 1 den sonra 2 yazılır.
            b nin hayatı sona erdiğinde b dtor çağıracak o da taban sınıfın yani a'nın
            dtor'ına çağrı yapacak. Ve ekrana 1 yazılacak

*****************************   
*****************************   
CEVAP :  121
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(31)//
#include <iostream>   

struct A {
    virtual void foo (int a = 1) {
        std :: cout << "A" << a;
    }
};

struct B : A { 
    virtual void foo (int a = 2) { 
        std :: cout << "B" << a; 
    } 
};

int main ()    
{   
    A* b = new B;
    b->foo();  
}   
*****************************   
AÇIKLAMA :  new B ile dinamik bir nesne oluşturulmuş. ve A* ile sınıfın sanal 
            fonksiyonuna çağrı yapılmıştır. default argument static türe 
            ilişkindir (global). Yani bunun virtual dispatch mechanism ile alakası yoktur.
            b->foo() çağırısında foo A sınıfında aranır. Derleyici bu kodu b->foo(1) şekline 
            dönüştürür. 
            Virtaul dispatch devreye girecek ve B sınıfının sanal fonksiyonu çağırılacaktır.

            B* b = new B;
            b->foo(); olsaydı derleyici compile time da parametreye bakarak B2 yazardı.
*****************************   
*****************************   
CEVAP :  B1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(32)//152
#include <iostream>
#include <type_traits>
   
int main ()    
{   
    if (std :: is_signed<char> :: value) {
        std :: cout << std :: is_same <char, signed char>::value;
    }
    else { 
        std :: cout << std :: is_same <char, unsigned char>::value;
    }  
}   
*****************************   
AÇIKLAMA : Derleyiciye bağlıdır. distinct türlerdir.  
*****************************   
*****************************   
CEVAP :  0
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(33)//254
#include <iostream>   
#include <type_traits>

int main ()    
{   
    std :: cout << std :: is_same_v < void(int), void (const int)>;
    std :: cout << std :: is_same_v < void(int*), void (const int*)>;
  
}   
*****************************   
AÇIKLAMA :  C de ve C++ da pointer olmayan const imzada bir farklılık oluşturmaz.!!!!!!!!!!
            int* ile const int* türleri kesinlikle farklı türlerdir.
            std :: cout << std :: is_same_v < void(int*), void (int* const)>; olsaydı 
            aynı türler olurlardı. CEVAP : 11 olurdu.

HATIRLATMA :
            void foo(int);
            void foo(const int);
            Burada redeclaration vardır.
*****************************   
*****************************   
CEVAP :  10
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(34)//293
#include <iostream>   

int main (int argc, char* argv[])    
{   
      std :: cout << (argv[argc] == nullptr);
}   
*****************************   
AÇIKLAMA :  Komut satırı argümanları konusu.
            argv[argc] yazılsaydı yine tanımsız davranış olurdu.
*****************************   
HATIRLATMA :
            int main() {
                int a[5] = {0};
                a[5]...dizinin boyutu diziye index olursa tanımsız davranış olur.
*****************************   
CEVAP :  1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(35)//248   
#include <algorithm>   
#include <iostream>

int main ()    
{   
    int x = 10;
    int y = 10;

    const int& max = std :: max (x, y);
    const int& min = std :: min (x, y);

    x = 11;
    y = 9;

    std :: cout << max << min;    
}   
*****************************   
AÇIKLAMA :  STL deki max ve min template leri referans döndürürler.
            İkisi de eşit ise birinci parametreyi döndürmek zorundadır.
*****************************   
*****************************   
CEVAP :  1111
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(36)//49 
#include <iostream> 

class C {
public :
    C (int i) : i(i) {
        std :: cout << i;
    }

    ~C () { 
        std :: cout << i + 5; 
    }
private :
    int i;
};

int main ()    
{   
    const C& c = C(1);
    C(2);
    C(3);  
}   
*****************************   
AÇIKLAMA :  life extension ile ilgilidir.
            Geçici nesneler evaluate edildikten sonra hayatları sona erer. 
            Ancak bu geçici nesne (PR value expr) değerini bir referansa bind 
            edilirse artık bu nesne referans olan ismin scope'unun sonunda hayatı 
            bitecektir.

            C(3) için ctor ve dtor çağırıldıktan sonra c(1) life extension olduğu 
            için en son onun dtor'ı çağırılır ve 6 ekrana basılır. 

            C(1) ile geçici nesne oluşturulup referansa bağlanmıştır.
*****************************   
CEVAP :  127386
*****************************
*****************************   
int main ()    
{   
    const C& c = C(1); 
    C(2); 
    C(3);   
}
böyle olsaydı CEVAP : 127638
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(37)//222
#include <iostream>   
#include <variant>

using namespace std;

int main ()    
{  
    variant <int, double, char> v;
    cout << v.index(); 
}   
*****************************   
AÇIKLAMA :  variant'ın def ctor'ı ilk tür argümanı cinsinden değer tutar. 
            Yani bu soru için variant int tutar.
*****************************   
*****************************   
CEVAP :  0
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(38)//41   
#include <iostream>   

int main ()    
{   
    std :: cout << 1["ABC"];  
}   
*****************************   
AÇIKLAMA :  Köşeli parantez operatoru için derleyici dıştaki operanda içteki operandın 
            toplama işlemine atadı ve burdan elde edilen adresi direference etti (*)
            *(1 + "ABC")
*****************************   
*****************************   
CEVAP :  B
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(39)//
#include <iostream>   

void f (int a = []() { static int b = 1; return b++; } ())
{
    std :: cout << a;
}

int main ()    
{   
    f();         //burda 1
    f();         //burda ++ oldu
}   
*****************************   
AÇIKLAMA :  []() { static int b = 1; return b++; } ()  default argument olan ifadedir.
            []() { static int b = 1; return b++; }  bu da bir lambda ifadesidir. 
            (gecici nesne)
            lambda ifadesi derleyiciye bir sınıf kodu yazdırır ve ifadeyi derleyici o
            sınıf türünden gecici nesneye dönüştürür.
            Varsayılan olan ifade her fonksiyon çağrısında ayrıca evaluate edilir.
*****************************   
*****************************   
CEVAP :  12
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(40)//188
#include <iostream>   

int main ()    
{   
    char* a = const_cast<char*>("Hello");
    a[4] = '\0';
    std :: cout << a;
}   
*****************************   
AÇIKLAMA :  const bir nesnenin değiştirilmesi tanımsız davranıştır. 
            C++ "Hello" türü const char *  (bu soruda const char [6] )
            C de türü char *               (bu soruda char[6] )
            
*****************************   
*****************************   
CEVAP :  UB
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(41)//126
#include <iostream>   

int foo () {
    return 10;
}

struct foobar {
    static int x;
    static int foo () {
        return 11;
    }
};

int foobar :: x = foo ();

int main ()    
{   
      std :: cout << foobar :: x;
}   
*****************************   
AÇIKLAMA :  name-look-up sorusudur.
            isim aramada static veri elemanlarının initiliazer'ı olan ifadelerdeki 
            isimler önce class scope'ta aranır. (int foobar :: x = foo() işlemindeki 
            foo fonksiyonu) bulunamazsa namespace de aranır.

            int foobar :: x = :: foo(); olsaydı globalde arardı 10 olurdu.
*****************************   
*****************************   
CEVAP :  11
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(42)//32  
#include <iostream>

struct X {
    X () { 
        std :: cout << "a";
    }

    X (const X& x) {
        std :: cout << "b";
    }

    const X& operator=(const X& x) {
        std :: cout << "c";
        return *this;
    }
};

int main ()    
{   
    X x;
    X y(x);      //direct init.
    X z = y;     //copy init.
    z = x;
}   
*****************************   
AÇIKLAMA :  Hayata getirilen nesnenin türü ile ilk değer verilen ifadenin türü aynı 
            ise copy ctor çağırılır. x def. init edildiği için def ctor çağırılır. (a yazdık)
            ilk değer veren ifade de x sınıfı türünden olduğu için copy ctor çağırıldı. 
            (b yazdık.)
            3. ifade de copy ctor çağırılır.
            Sonuncuda ise atama op. çağırılır c yazar.            
*****************************   
*****************************   
CEVAP :  abbc
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(43)//140
#include <iostream>   

using namespace std;

size_t get_size_1 (int* arr) {
    return sizeof arr;
}

size_t get_size_2 (int arr[]) { 
    return sizeof arr; 
}

size_t get_size_3 (int(&arr)[10]) {       //fonk parametresi diziye referanstır.
    return sizeof arr; 
}

int main ()    
{   
    int array[10];
    //Assume sizeof (int*) '= sizeof (int[10]);

    cout << (sizeof(array) == get_size_1 (array));
    cout << (sizeof(array) == get_size_2 (array));
    cout << (sizeof(array) == get_size_3 (array));
}   
*****************************   
AÇIKLAMA :  
*****************************   
*****************************   
CEVAP :  001
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(44)//190  
#include <iostream>  

struct A {
    A (int i) : m_i(i) {}
    operator bool() const {
        return m_i;
    }
};

int main ()    
{   
    A a1(1), a2(2);
    std :: cout << a1 + a2 << (a1 == a2); 
}   
*****************************   
AÇIKLAMA :  operator bool explicit olmadığı için implicit type convertion yapabilecektir. 
            explicit olsaydı syntax error olurdu. Sınıfın toplama ve == fonksiyonları 
            olsaydı onlar çağırılırdı. Bu işlemlerin yapılabilmesi için a nesnesinin 
            primitive int nesnesine dönüştürülmesi gerekir.
            a1 + a2 için oeprator bool çağırılır. a1 de a2 de 0 dan büyük oldukları için 
            true döndürür. Daha sonra toplama işlemi yapıldı. 
            true dönen yani 1 + 1 oldu 2 elde ettik.

            a1 == a2 için bool ile bool eşitliğine bakıldı 1 döndü.
            
*****************************   
*****************************   
CEVAP :  21
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(45)//125
#include <iostream>   

using namespace std;

template <class T> 
void f (T) {
    static int i = 0;
    cout << ++i;
}

int main ()    
{   
    f(1);
    f(1.0);
    f(1); 
}   
*****************************   
AÇIKLAMA :  Bu bir fonksiyon değil şablondur. Bu template'ten her özelleştirme her 
            speciliazition için her defasından ayrı bir yerel değişken var anlamındadır.
            f(1) çağırıldığında 1 argümanı ile template argument deduction ile T türü 
            int olarak deduction yapılır. 
            f(1.0) da tür değiştiği için static yerel değişken sıfır olarak başlar.
            En son f(1) de ise aynı tür olduğu için 1 + 1 olur.
*****************************   
*****************************   
CEVAP :  112
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(46)//107
#include <iostream>
#include <vector>
   
int f() {
    std :: cout << "f";
    return 0;
}

int g() { 
    std :: cout << "g"; 
    return 0; 
}

void h (std :: vector<int> v) {}

int main ()    
{   
    h ({ f(), g() }); 
}   
*****************************   
AÇIKLAMA :  { f(), g() } ifadesi initializer list. Çağırılan h fonksiyonunun parametresi 
            olan vector'e init. list'in int açılımı türünden nesne göndermiş oluruz.
            f ya da g den hangisinin önce çağırılacağı derleyiciye bağlı değildir. 
            Initializer listte sıraya göredir.
*****************************   
*****************************   
CEVAP :  fg
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(47)//116
#include <iostream>   
#include <utility>

int y(int &) {
    return 1;
}

int y(int &&) { 
    return 2; 
}

template <class T> 
int f (T&& x) {
    return y(x);
}

template <class T>  
int g (T&& x) { 
    return y(std :: move(x)); 
}

template <class T>                          //perfect forwarding yapan sadece budur.
int h (T&& x) { 
    return y(std :: forward<T>(x)); 
}

int main ()    
{   
    int i = 10;
    std :: cout << f(i) << f(20);
    std :: cout << g(i) << g(20);
    std :: cout << h(i) << h(20);      
}   
*****************************   
AÇIKLAMA :  T&& x şeklindeki parametrelere forwarding reference ya da universal 
            reference. Bu sağ taraf referansı değildir. perfect forwarding için 
            kullanılacaktır. Burada yok ama. 
            return y(x) te isim olan ifadelerin value kategorisi L value expression. 
            Dolayısıyla parametresi sol taraf değeri olan return 1 dönen çağırılacaktır. 
            f(i) ve f(20) aynı şekilde çağırılırlar.

            g fonksiyonunda çağrı move ile sağ tarafa dönüştürülmüş olduğu için return 
            2 olan fonksiyon çağırılır. 

            forward ise value category ve constluğu korur. fonksiyona gönderilen ifade 
            ne ise onu döndürür. h(i) L value olduğu için return 1, h(20) sağ taraf 
            olduğu için return 2 çağırılır.
*****************************   
*****************************   
CEVAP :  112212
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(48)//287 
#include <iostream>   
#include <string>

int main ()    
{   
    using namespace std :: string_literals;

    std :: string s1 ("hello world", 5);   //data ctor
    std :: string s2 ("hello world"s, 5);  //substring ctor

    std :: cout << s1 << s2;
}   
*****************************   
AÇIKLAMA :  "hello world", 5 string sınıfının data ctor denir. Bir adres alır, 
             fakat onu cstring olarak kullanmaz.Yani sonundaki null karakter ile 
            kullanmaz. Bir de size_t türünden değer alır. s1 hello
            s2 deki durum ise user defined literal durumudur. Aldığı size_t indisinden 
            başlayarak kalan hepsini alır. s2 ise world alır.
*****************************   
*****************************   
CEVAP :  hello world
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(49)//
#include <iostream>  

struct A {
    A () {
        std :: cout << "A";
    }

    ~A () {
        std :: cout << "a";
    }
};

int main ()    
{   
    std :: cout << "main";
    return sizeof new A;
}   
*****************************   
AÇIKLAMA :  sizeof operatorunun operandı unevaluated context bir ifadedir.
            Yani return sizeof new A ifadesinde bir nesne oluşturulması durumu yoktur.
*****************************   
*****************************   
CEVAP :  main
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(50)//
#include <iostream> 
#include <initializer_list>

class C {
public :
    C() = default;
    C (const C&) {
        std :: cout << 1;
    }
};

void f (std :: initializer_list<C> i) {} 

int main ()    
{   
    C c;
    std :: initializer_list<C> i { c };
    f(i);
    f(i);
}   
*****************************   
AÇIKLAMA :  initializer_list için copy ctor çağırıldı. Çünkü bu listeyi oluşturmak 
            için argüman olan ifadeden listede tutulacak nesneye kopyalama yapılır. 
            initializer list için derleyici const bir dizi oluşturur.
*****************************   
*****************************   
CEVAP :  1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(51)//162
#include <iostream>  

void f() {
    std :: cout << 1;
};

template<typename T>
struct B {
    void f () {
        std :: cout << 2;
    }
};

template<typename T> 
struct D : B<T> { 
    void g () { 
        f();
    } 
};

int main ()    
{   
    D<int> d;
    d.g();
}   
*****************************   
AÇIKLAMA :  template olmasaydı f() fonksiyonu önce class scope'ta aranacaktı. 
            CEVAP : 2 olurdu. Template var iken isim nitelenmemiş ise Based 
            class ta isim aranmaz.
*****************************   
*****************************   
CEVAP : 1 
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(52)//25
#include <iostream>  
#include <limits>

int main ()    
{   
    int i = std :: numeric_limits<int :: max();
    std :: cout << ++;      
}   
*****************************   
AÇIKLAMA :  işaretli türlerde taşma tanımsız davranıştır.
*****************************   
*****************************   
CEVAP :  UB
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(53)//
#include <iostream> 
#include <string>

void f (const std :: string&) {
    std :: cout << 1;
}

void f (const void*) { 
    std :: cout << 2; 
} 

int main ()    
{   
    f ("foo");
    const char* bar = "bar";
    f (bar);  
}   
*****************************   
AÇIKLAMA :  
*****************************   
*****************************   
CEVAP :  22
*****************************

/***/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/********************************************************************************************************************/

(54)//184  
#include <iostream>   

struct Base {
    void f(int) {
        std :: cout << "i";
    }
};

struct Derived : Base {
    void f(double) {
        std :: cout << "d";
    }
};

int main ()    
{   
    Derived d;
    int i = 0;
    d.f(i);  
}   
*****************************   
AÇIKLAMA :  f (i) çağrısı türemiş sınıf ile yapıldığı için isim arama türemiş 
            sınıfta yapılır. Function overloading durumu yoktur.
            d.Base :: f(i); yapılırsa isim arama taban sınıfta yapılır ve CEVAP : i olur.
*****************************   
*****************************   
CEVAP :  d
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(55)//
#include <iostream>   

int main ()    
{   
    void* p = &p;
    std :: cout << bool(p); 
}   
*****************************   
AÇIKLAMA :  pointer değişkene kendi adresiyle ilk değer verdik.
            pointer to bool dönüşümü yapıldı. nullptr ise false, değilse true.
*****************************   
*****************************   
CEVAP :  1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(56)//  
#include <iostream>   

class show_id {
public : 
    ~show_id () {
        std :: cout << id;
    }
    int id;
};

int main ()    
{   
    delete [] new show_id[3] { {0}, {1}, {2} }; 
}   
*****************************   
AÇIKLAMA :  array new operatoru kullanılmıştır. Dtor lar sondan başlayaarak çağırılır.
*****************************   
*****************************   
CEVAP :  210
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(57)//217
#include <iostream> 

int main ()    
{   
    int i = 1;
    int const& a = i > 0 ? i : 1;
    i = 2;
    std :: cout << i << a;
}   
*****************************   
AÇIKLAMA : i > 0 ? i : 1  ifadesi L value expr. olursa a i nesnesine referans olur. 
           Eğer R value expr olursa a nesnesi temporary bir nesneye referans olacaktır.
           ? operatorunun sağ operandlarının 2 si de L value expr olsaydı ifade tamamen 
           L value expr olurdu. Ancak i L value, 1 ise R value expr olduğu için ifade R 
           value expr olur. Bu yüzden bu ifade geçici nesneye
           bağlanan referanstır. Bu durumda a nesnesi i nesnesine referans değil demektir.
*****************************   
*****************************   
CEVAP :  21
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(58)//249
#include <iostream>   

using namespace std;

int main ()    
{   
    int a = '0';
    char const& b = a;
    cout << b;
    a++;
    cout << b;  
}   
*****************************   
AÇIKLAMA :  char & b = a; olsaydı syntax error olurdu. yine b nesnesi geçici bir nesneye 
            referanstır. int türden char türe referans olmaz.
*****************************   
*****************************   
CEVAP :  00
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(59)//15
#include <iostream>  
#include <exception>

int x = 0;

class A {
public :
    A () {
        std :: cout << 'a';
        if (x++ == 0) {
            throw std :: exception();
        }
    }

    ~A () {
        std :: cout 'A';
    }
};

class B { 
public : 
    B () { 
        std :: cout << 'b'; 
    } 
    ~B () { 
        std :: cout 'B'; 
    } 
    
    A a;   
};

void foo () {
    static B b;
}

int main ()    
{   
    try {
        foo ();
    }
    catch (std :: exception&) {
        std :: cout << 'c';
        foo();
    }  
}   
*****************************   
AÇIKLAMA :  Bir sınıf nesnesinin hayata gelmiş olması için programın akışının ctor 
            ana bloğunun sonuna kadar gelmesi gerekir!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            
*****************************   
*****************************   
CEVAP :  acabBA
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(60)//31
#include <iostream> 

struct X {
    x () {
        std :: cout << "X";
    }
};

struct Y {
    Y (const X& x) {
        std :: cout << "Y";
    }

    void f() {
        std :: cout << "f";
    }
};

int main ()    
{   
    Y y ( X() ); 
    y.f(); 
}   
*****************************   
AÇIKLAMA :  burada Y sınıfı türünden oluşan bir y nesnesini X sınıfı türünden bir 
            geçici nesne ile hayata getirmiş olmuyoruz. Çünkü aynı zamanda fonksiyon 
            bildirimi sentaksına uyduğu için; geri dönüş değeri Y olan adı y olan 
            parametresi function pointer olan bir fonksiyon bildirimidir. 
            (Y y ( X() ) ) ifadesi)

            Y y ( X{} ) olursa most vexing parse olmaz. CEVAP XYf olur. ya da Y y { X() } 
            olsaydı yine most vexing parse olmazdı.
            
*****************************   
*****************************   
CEVAP :  most vexing parse. syntax error.
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(61)//130
#include <iostream> 

using namespace std;

template <typename T>
void adl (T) {
    cout << "T";
}

struct S {
};

template <typename T>
void call_adl (T t) {
    adl( S() );
    adl(t);
}

void adl (S) {
    cout << "S";
}

int main ()    
{   
    call_adl( S() );  
}   
*****************************   
AÇIKLAMA :  ---
*****************************   
*****************************   
CEVAP :  TS
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/

(62)//
#include <iostream> 

int main ()    
{   
    int n = sizeof (0)["abcdefghij"];
    std :: cout << n;
}   
*****************************   
AÇIKLAMA :  operator önceliği ile ilgili bir sorudur.
            [] operatoru mu sizeof operatoru mu düşük öncelikli?
                sizeof daha düşük önceliklidir.
            Cevap char türünün  ( (0)["abcdefghij"] ) sizeof değerinin 1 olmasıdır.
*****************************   
*****************************   
CEVAP :  1
*****************************

/******************************************************************************************************************************************************************************/
/******************************************************************************************************************************************************************************/
								
								                                                 /* THE END */
                                  
                                  
